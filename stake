import time
import json
from decimal import Decimal, getcontext
from web3 import Web3
from wallet_setup import web3, wallet_address, private_key, weth_contract, usdc_contract, aero_contract

getcontext().prec = 28

# Contract addresses
NPM_ADDRESS = web3.to_checksum_address("0x827922686190790b37229fd06084350e74485b72")
WETH_ADDRESS = web3.to_checksum_address("0x4200000000000000000000000000000000000006")
USDC_ADDRESS = web3.to_checksum_address("0x833589fCD6eDb6E08f4c7C32D4f71b54bdA02913")
AERO_ADDRESS = web3.to_checksum_address("0x940181a94A35A4569E4529A3CDfB74e38FD98631")

# Correct gauge address (proxy contract)
CL_GAUGE_ADDRESS = web3.to_checksum_address("0xF33a96b5932D9E9B9A0eDA447AbD8C9d48d2e0c8")

# NPM ABI
NPM_ABI = '''
[
    {"inputs":[{"internalType":"address","name":"owner","type":"address"}],"name":"balanceOf","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"view","type":"function"},
    {"inputs":[{"internalType":"address","name":"owner","type":"address"},{"internalType":"uint256","name":"index","type":"uint256"}],"name":"tokenOfOwnerByIndex","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"view","type":"function"},
    {"inputs":[{"internalType":"uint256","name":"tokenId","type":"uint256"}],"name":"positions","outputs":[{"internalType":"uint96","name":"nonce","type":"uint96"},{"internalType":"address","name":"operator","type":"address"},{"internalType":"address","name":"token0","type":"address"},{"internalType":"address","name":"token1","type":"address"},{"internalType":"int24","name":"tickSpacing","type":"int24"},{"internalType":"int24","name":"tickLower","type":"int24"},{"internalType":"int24","name":"tickUpper","type":"int24"},{"internalType":"uint128","name":"liquidity","type":"uint128"},{"internalType":"uint256","name":"feeGrowthInside0LastX128","type":"uint256"},{"internalType":"uint256","name":"feeGrowthInside1LastX128","type":"uint256"},{"internalType":"uint128","name":"tokensOwed0","type":"uint128"},{"internalType":"uint128","name":"tokensOwed1","type":"uint128"}],"stateMutability":"view","type":"function"},
    {"inputs":[{"internalType":"address","name":"to","type":"address"},{"internalType":"uint256","name":"tokenId","type":"uint256"}],"name":"approve","outputs":[],"stateMutability":"nonpayable","type":"function"},
    {"inputs":[{"internalType":"uint256","name":"tokenId","type":"uint256"}],"name":"getApproved","outputs":[{"internalType":"address","name":"","type":"address"}],"stateMutability":"view","type":"function"}
]
'''

# CL Gauge ABI with key functions
CL_GAUGE_ABI = '''
[
    {"inputs":[{"internalType":"uint256","name":"_tokenId","type":"uint256"}],"name":"deposit","outputs":[],"stateMutability":"nonpayable","type":"function"},
    {"inputs":[{"internalType":"uint256","name":"tokenId","type":"uint256"}],"name":"withdraw","outputs":[],"stateMutability":"nonpayable","type":"function"},
    {"inputs":[],"name":"getReward","outputs":[],"stateMutability":"nonpayable","type":"function"},
    {"inputs":[],"name":"periodFinish","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"view","type":"function"}
]
'''

# ERC20 ABI
ERC20_ABI = '''
[
    {"constant":true,"inputs":[{"name":"owner","type":"address"}],"name":"balanceOf","outputs":[{"name":"","type":"uint256"}],"payable":false,"stateMutability":"view","type":"function"},
    {"constant":true,"inputs":[],"name":"symbol","outputs":[{"name":"","type":"string"}],"payable":false,"stateMutability":"view","type":"function"},
    {"constant":true,"inputs":[],"name":"decimals","outputs":[{"name":"","type":"uint8"}],"payable":false,"stateMutability":"view","type":"function"}
]
'''

# Initialize contracts
npm_contract = web3.eth.contract(address=NPM_ADDRESS, abi=NPM_ABI)
cl_gauge_contract = web3.eth.contract(address=CL_GAUGE_ADDRESS, abi=CL_GAUGE_ABI)
aero_token = web3.eth.contract(address=AERO_ADDRESS, abi=ERC20_ABI)

def list_positions():
    """List all CL positions owned by the user"""
    try:
        # Get number of positions owned by the user
        num_positions = npm_contract.functions.balanceOf(wallet_address).call()
        if num_positions == 0:
            print("You don't have any positions.")
            return []
        positions = []
        print(f"Found {num_positions} position(s):")
        for i in range(num_positions):
            # Get token ID for each position
            token_id = npm_contract.functions.tokenOfOwnerByIndex(wallet_address, i).call()
            # Get position details
            position = npm_contract.functions.positions(token_id).call()
            # Extract relevant details
            token0 = position[2]
            token1 = position[3]
            tick_lower = position[5]
            tick_upper = position[6]
            liquidity = position[7]
            # Determine token names
            token0_name = "WETH" if token0.lower() == WETH_ADDRESS.lower() else "USDC" if token0.lower() == USDC_ADDRESS.lower() else "OTHER"
            token1_name = "USDC" if token1.lower() == USDC_ADDRESS.lower() else "WETH" if token1.lower() == WETH_ADDRESS.lower() else "OTHER"
            
            # Store position details
            position_info = {
                'token_id': token_id,
                'token0': token0,
                'token1': token1,
                'token0_name': token0_name,
                'token1_name': token1_name,
                'tick_lower': tick_lower,
                'tick_upper': tick_upper,
                'liquidity': liquidity
            }
            positions.append(position_info)
            # Display position
            print(f"Position #{i+1} (Token ID: {token_id}):")
            print(f"  Tokens: {token0_name}/{token1_name}")
            print(f"  Tick Range: {tick_lower} to {tick_upper}")
            print(f"  Liquidity: {liquidity}")
            
            # Check if approved for gauge
            try:
                approved = npm_contract.functions.getApproved(token_id).call()
                approved_status = "Approved for gauge" if approved.lower() == CL_GAUGE_ADDRESS.lower() else "Not approved for gauge"
                print(f"  Status: {approved_status}")
            except Exception as e:
                print(f"  Could not check approval status: {e}")
            
            print()
        return positions
    except Exception as e:
        print(f"Error listing positions: {e}")
        return []

def check_position_approval(token_id):
    """Check if a position is approved for the gauge"""
    try:
        approved = npm_contract.functions.getApproved(token_id).call()
        return approved.lower() == CL_GAUGE_ADDRESS.lower()
    except Exception as e:
        print(f"Error checking approval status: {e}")
        return False

def approve_position_for_staking(token_id):
    """Approve the gauge to use our position token"""
    try:
        # Check if already approved
        if check_position_approval(token_id):
            print(f"Position {token_id} is already approved for staking")
            return True
            
        print(f"Approving position {token_id} for staking...")
        
        # Get fresh nonce and gas price
        nonce = web3.eth.get_transaction_count(wallet_address)
        gas_price = int(web3.eth.gas_price * 1.2)  # 20% higher gas price for faster confirmation
        
        # Build transaction
        tx = npm_contract.functions.approve(CL_GAUGE_ADDRESS, token_id).build_transaction({
            'from': wallet_address,
            'gas': 120000,
            'gasPrice': gas_price,
            'nonce': nonce,
            'chainId': web3.eth.chain_id
        })
        
        # Sign and send transaction
        signed_tx = web3.eth.account.sign_transaction(tx, private_key)
        tx_hash = web3.eth.send_raw_transaction(signed_tx.raw_transaction)
        tx_hash_hex = tx_hash.hex()
        
        print(f"Approval transaction sent: {tx_hash_hex}")
        print(f"Track on BaseScan: https://basescan.org/tx/{tx_hash_hex}")
        
        # Wait for transaction receipt
        print("Waiting for transaction to be mined...")
        receipt = web3.eth.wait_for_transaction_receipt(tx_hash, timeout=300)
        if receipt.status == 1:
            print(f"Position {token_id} approval successful!")
            return True
        else:
            print(f"Failed to approve position {token_id}")
            return False
            
    except Exception as e:
        print(f"Error approving position for staking: {e}")
        return False

def stake_position(token_id):
    """Stake a CL position in the gauge using raw transaction data"""
    try:
        # First ensure position is approved
        if not approve_position_for_staking(token_id):
            print("Position approval failed. Cannot stake.")
            return False
        
        print(f"Position {token_id} is approved, proceeding with staking...")
        time.sleep(5)  # Wait a moment to ensure approval transaction is fully processed
        
        # Get fresh nonce and gas price
        nonce = web3.eth.get_transaction_count(wallet_address)
        gas_price = int(web3.eth.gas_price * 1.2)  # 20% higher gas price for faster confirmation
        
        # Build raw transaction data - directly matching successful transaction format
        # Function selector for deposit(uint256)
        function_selector = "0xb6b55f25"
        # Convert token ID to 32-byte padded hex
        token_id_hex = hex(token_id)[2:].zfill(64)
        # Combine them
        data = function_selector + token_id_hex
        
        # Create transaction
        raw_tx = {
            'from': wallet_address,
            'to': CL_GAUGE_ADDRESS,
            'gas': 150000,
            'gasPrice': gas_price,
            'nonce': nonce,
            'data': data,
            'chainId': web3.eth.chain_id
        }
        
        # Sign and send transaction
        signed_tx = web3.eth.account.sign_transaction(raw_tx, private_key)
        tx_hash = web3.eth.send_raw_transaction(signed_tx.raw_transaction)
        tx_hash_hex = tx_hash.hex()
        
        print(f"Staking transaction sent: {tx_hash_hex}")
        print(f"Track on BaseScan: https://basescan.org/tx/{tx_hash_hex}")
        
        # Wait for transaction receipt
        print("Waiting for transaction to be mined...")
        receipt = web3.eth.wait_for_transaction_receipt(tx_hash, timeout=300)
        
        if receipt.status == 1:
            print(f"Position {token_id} successfully staked!")
            return True
        else:
            print(f"Failed to stake position {token_id}")
            return False
            
    except ValueError as e:
        error_str = str(e)
        print(f"Error staking position: {error_str}")
        # Check for specific error messages
        if "execution reverted" in error_str.lower():
            if "already staked" in error_str.lower():
                print("Position appears to already be staked.")
            elif "nft" in error_str.lower():
                print("There might be an issue with the NFT ownership or permissions.")
        return False
    except Exception as e:
        print(f"Error staking position: {e}")
        return False

def unstake_position(token_id):
    """Unstake a CL position from the gauge using raw transaction data"""
    try:
        print(f"Preparing to unstake position {token_id}...")
        
        # Get fresh nonce and gas price
        nonce = web3.eth.get_transaction_count(wallet_address)
        gas_price = int(web3.eth.gas_price * 1.2)  # 20% higher gas price for faster confirmation
        
        # Build raw transaction data
        # Function selector for withdraw(uint256)
        function_selector = "0x2e1a7d4d"
        # Convert token ID to 32-byte padded hex
        token_id_hex = hex(token_id)[2:].zfill(64)
        # Combine them
        data = function_selector + token_id_hex
        
        # Create transaction
        raw_tx = {
            'from': wallet_address,
            'to': CL_GAUGE_ADDRESS,
            'gas': 150000,
            'gasPrice': gas_price,
            'nonce': nonce,
            'data': data,
            'chainId': web3.eth.chain_id
        }
        
        # Sign and send transaction
        signed_tx = web3.eth.account.sign_transaction(raw_tx, private_key)
        tx_hash = web3.eth.send_raw_transaction(signed_tx.raw_transaction)
        tx_hash_hex = tx_hash.hex()
        
        print(f"Unstaking transaction sent: {tx_hash_hex}")
        print(f"Track on BaseScan: https://basescan.org/tx/{tx_hash_hex}")
        
        # Wait for transaction receipt
        print("Waiting for transaction to be mined...")
        receipt = web3.eth.wait_for_transaction_receipt(tx_hash, timeout=300)
        
        if receipt.status == 1:
            print(f"Position {token_id} successfully unstaked!")
            return True
        else:
            print(f"Failed to unstake position {token_id}")
            return False
            
    except ValueError as e:
        error_str = str(e)
        print(f"Error unstaking position: {error_str}")
        if "execution reverted" in error_str.lower():
            if "not staked" in error_str.lower():
                print("Position does not appear to be staked.")
        return False
    except Exception as e:
        print(f"Error unstaking position: {e}")
        return False

def check_aero_balance():
    """Check current AERO balance"""
    try:
        # Get current AERO balance
        aero_balance = Decimal(aero_token.functions.balanceOf(wallet_address).call()) / Decimal(10**18)
        print(f"Current AERO balance: {aero_balance:.6f}")
        return aero_balance
    except Exception as e:
        print(f"Error checking AERO balance: {e}")
        return Decimal('0')

def try_low_level_call(function_sig, params=None):
    """Try a low-level call to the contract"""
    try:
        print(f"Checking {function_sig}...")
        
        # Generate function selector
        function_selector = web3.keccak(text=function_sig).hex()[:10]
        
        # Build call data
        call_data = function_selector
        
        # Add params if needed
        if params:
            for param in params:
                if isinstance(param, str) and param.startswith("0x"):
                    # Address parameter
                    call_data += "0" * 24 + param[2:].lower()
                else:
                    # Other parameter (assume uint256)
                    call_data += hex(param)[2:].zfill(64)
        
        # Make the call
        result = web3.eth.call({
            'to': CL_GAUGE_ADDRESS,
            'data': call_data
        })
        
        if result and len(result) > 0 and result.hex() != "0x":
            # Try to interpret result as uint256
            try:
                value = int(result.hex(), 16)
                if function_sig == "periodFinish()":
                    finish_date = time.strftime('%Y-%m-%d %H:%M:%S', time.localtime(value))
                    print(f"Reward period ends on: {finish_date}")
                else:
                    print(f"Value: {value}")
                    if "balance" in function_sig.lower():
                        print(f"Value in AERO: {Decimal(value) / Decimal(10**18):.6f}")
            except:
                pass
                
            return True
        else:
            print(f"No data returned for {function_sig}")
            return False
            
    except Exception as e:
        print(f"Call to {function_sig} failed: {e}")
        return False

def claim_rewards():
    """Claim accrued AERO rewards using raw transaction"""
    try:
        # Get initial AERO balance for comparison
        initial_aero = check_aero_balance()
        
        # Get fresh nonce and gas price
        nonce = web3.eth.get_transaction_count(wallet_address)
        gas_price = int(web3.eth.gas_price * 1.2)  # 20% higher gas price for faster confirmation
        
        # Build raw transaction data
        # Function selector for getReward()
        function_selector = "0x3d18b912"
        
        # Create transaction
        raw_tx = {
            'from': wallet_address,
            'to': CL_GAUGE_ADDRESS,
            'gas': 150000,
            'gasPrice': gas_price,
            'nonce': nonce,
            'data': function_selector,
            'chainId': web3.eth.chain_id
        }
        
        # Sign and send transaction
        signed_tx = web3.eth.account.sign_transaction(raw_tx, private_key)
        tx_hash = web3.eth.send_raw_transaction(signed_tx.raw_transaction)
        tx_hash_hex = tx_hash.hex()
        
        print(f"Claim transaction sent: {tx_hash_hex}")
        print(f"Track on BaseScan: https://basescan.org/tx/{tx_hash_hex}")
        
        # Wait for transaction receipt
        print("Waiting for transaction to be mined...")
        receipt = web3.eth.wait_for_transaction_receipt(tx_hash, timeout=300)
        
        if receipt.status == 1:
            print("Transaction successful! Checking for received rewards...")
            
            # Check if balance increased
            time.sleep(5)  # Give blockchain time to update
            final_aero = check_aero_balance()
            
            if final_aero > initial_aero:
                received = final_aero - initial_aero
                print(f"Successfully claimed {received:.6f} AERO rewards!")
            else:
                print("Transaction was successful, but no new rewards were received.")
                print("This could mean you have no unclaimed rewards at this time.")
                
            return True
        else:
            print("Failed to claim rewards.")
            return False
            
    except Exception as e:
        print(f"Error claiming rewards: {e}")
        return False

def diagnose_gauge():
    """Perform diagnostics on the gauge contract"""
    print("\n--- Gauge Diagnostics ---")
    
    # Check if contract exists
    try:
        code = web3.eth.get_code(CL_GAUGE_ADDRESS)
        if code and len(code) > 2:
            print(f"✓ Gauge contract exists at {CL_GAUGE_ADDRESS}")
        else:
            print(f"❌ No contract code found at {CL_GAUGE_ADDRESS}")
            return False
    except Exception as e:
        print(f"Error checking contract code: {e}")
        return False
    
    # Only check functions that are known to work
    try_low_level_call("periodFinish()", [])
    
    # Check balance of AERO in gauge
    try:
        aero_balance = aero_token.functions.balanceOf(CL_GAUGE_ADDRESS).call()
        aero_balance_decimal = Decimal(aero_balance) / Decimal(10**18)
        print(f"AERO balance in gauge: {aero_balance_decimal:,.6f}")
        
        if aero_balance == 0:
            print("❗ The gauge has no AERO tokens - this means it can't pay rewards!")
    except Exception as e:
        print(f"Error checking AERO balance in gauge: {e}")
    
    return True

def main():
    print("Aerodrome CL Position Staking Tool")
    print("----------------------------------")
    
    # Track the current position ID
    current_position_id = None
    
    while True:
        print("\nWhat would you like to do?")
        print("1. List positions")
        print("2. Stake position")
        print("3. Check rewards")
        print("4. Claim rewards") 
        print("5. Unstake position")
        print("6. Run gauge diagnostics")
        print("7. Exit")
        
        choice = input("Enter your choice (1-7): ")
        
        if choice == '1':
            # List positions
            positions = list_positions()
            
            if positions:
                # Update current position to the first one
                current_position_id = positions[0]['token_id']
                print(f"Using position ID: {current_position_id}")
        
        elif choice == '2':
            # Stake a position using raw transaction
            if current_position_id is None:
                positions = list_positions()
                if positions:
                    token_id = positions[0]['token_id']
                    print(f"Found position {token_id} to stake.")
                else:
                    print("No positions found to stake.")
                    continue
            else:
                token_id = current_position_id
            
            # Confirm staking
            confirm = input(f"Stake position {token_id}? (y/n): ")
            if confirm.lower() == 'y':
                stake_position(token_id)
            
        elif choice == '3':
            # Check rewards
            print("\n--- AERO Rewards Information ---")
            check_aero_balance()
            diagnose_gauge()
            
        elif choice == '4':
            # Claim rewards
            claim_rewards()
            
        elif choice == '5':
            # Unstake position
            if current_position_id is None:
                positions = list_positions()
                if positions:
                    current_position_id = positions[0]['token_id']
                else:
                    print("No positions found to unstake.")
                    continue
            
            # Confirm unstaking
            confirm = input(f"Unstake position {current_position_id}? (y/n): ")
            if confirm.lower() == 'y':
                unstake_position(current_position_id)
            
        elif choice == '6':
            # Run diagnostics
            diagnose_gauge()
            
        elif choice == '7':
            print("Exiting...")
            break
            
        else:
            print("Invalid choice. Please enter a number between 1 and 7.")

if __name__ == "__main__":
    main()
